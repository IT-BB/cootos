###array、slice、map
####array
array就是数组，它的定义方式如下：

    //var 数组名称 [数组的长度]存储元素的类型
    var a [10]int
<br/>

    var b [10]int //声明了一个int类型的数组
    b[0] = 42     //数组下标是从0开始
    b[2] = 50     //赋值操作
    fmt.Println("数组b的第一个值是：%d\n",b[0])    //获取数据，返回42
    fmt.Println("数组b的最后一个值是：%d\n",b[9])  //返回未赋值的最后一个元素，默认返回0
由于长度也是数组类型的一部分，因此[3]int与[4]int是不同的类型，数组也就不能改变长度。     
数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是改数组的副本，而不是它的指针。    
如果使用指针，那么就需要用到后面介绍的slice类型了。    
数组可以使用另外一种`:=`来声明。

    a := [3]int{1,2,3}  //声明了一个长度为3的int数组
    b := [10]int{1,2,3} //声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其他默认为0
    c := [...]int{4,5,6} //可以省略长度而采用`...`的方式，Go 语言会自动根据元素个数来计算
也许你会说，我想数组里面的值还是数组，Go语言支持嵌套数组，即多维数组。

    //声明了一个二维数组，改数组以两个数组为元素，其中每个数组中有个4个int类型的元素。
    a := [2][4]int{[4]int{1,2,3,4},[4]int{5,6,7,8}}
    
    //如果内部的元素和外部的一样，那么上面的声明可以简化，直接忽略内部的类型
    a := [2][4]int{{1,2,3,4}{5,6,7,8}}
####slice
在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要”动态数组“在Go语言里面这种数据结构叫slice。    
slice并不是真在意义上的动态数组，而是一个引用类型。     
slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。

    //和声明array一样，只是少了长度
    var a []int
接下来我们可以声明一个slice，并初始化数据，如下所示：

    a := []byte {'a','b','c','d'}
slice可以从一个数组或一个已经存在的slice中再次声明。    
slice通过array[i:j]来获取，其中i是数组开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。

    //声明一个含有10个元素,元素类型为byte的数组
    var a = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k'}
    
    //声明两个含有byte的slice
	var b, c []byte
    
    //b指向数组的第3个元素开始，并到第5个元素结束
	b = a[2:5]
    //现在b含有元素：a[2]、a[3]、a[4]
    
    //c是数组a的另一个slice
	c = a[3:5]
    //c的元素是：a[3]、a[4]
 - 注：slice和数组在声明数组时，方括号内写明了数组的长度或使用...自动计算长度，而声明slice时，方括号内没有任何字符。                         
slice有一些简便的操作。    
 - slice 的默认开始位置是0,array[:n]等价于array[0:n]
 - slice 的第二个序列默认是数组的长度，array[n:]等价于array[n:len(array)]           
 - 如果从一个数组里面直接获取slice，可以这样array[:]，因为默认第一个序列是0，第二个是数组的长度，即等价于array[0:len(array)]    

下面这个例子展示了更多关于slice的操作。

    //声明一个数组
    var a = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k'}
    
    //声明两个slice
    var as, bs []byte
    
    //演示一些简便操作
    as = a[:3] //等价于 as = a[0:3]
    as = a[5:] //等价于 as = a[5:9]
    as = a[:] //等价于 as = a[0:9]
    
    as = a[3:7] //as包含元素 d,e,f,g len=4,cap=7
    bs = as[1:3] //bs包含as[1],as[2]也就是e,f
    bs = as[:3] //bs包含as[0],as[1],as[2]也就是d,e,f
    bs = as[0:5] //对slice的slice可以在cap范围内扩展，此时bs包含：d,e,f,g,h
    bs = as[:] //bs包含所有as的元素：d,e,f,g

slice是引用类型，所以当引用改变其中元素的值时，其他的所有引用都会改变改值，例如：

    
