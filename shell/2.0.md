#命令
#####break命令
你可以用这个命令在控制条件未满足之前，跳出for、while或untill循环。你可以为break命令提供一个额外的数值参数来表明需要跳出的循环层数，但我们并不建议这么做，因为它将大大降低程序的可读性，在默认情况下，beak只跳出一层循环。
```bash
#!/bin/sh
rm -rf fred*
echo > fred1
echo > fred2
mkdir fred3
echo > fred4

for file in fred*
do
	if [ -d "$file" ];then
		break;
	fi
done

echo "first directory starting fred was $file"
rm -rf fred*
exit 0
```
输出
```text
first directory starting fred was fred3
```
#####:命令
冒号`:`命令是一个空命令。它偶尔会被用于简化条件逻辑，相当于true的一个别名。由于它时内置命令，所以它运行的比true快，但它的输出可读性较差。
你可能会看到将它用作while循环的条件，`while :`实现了一个五星循环，代替了更常见的while true				
`:`结构也会被用在变量的条件设置中，例如：
```bash
: ${var:=value}
```
如果没有`:`，shell将试图把$var当作一条命令来处理。			
在一些shell脚本，主要是一些旧的shell脚本中，你可能会看到冒号被用在一行的开头来表示一个注释，但现代的脚本总是用`#`来开始一个注释行，因为这样做执行效率高。
```bash
#!/bin/sh
rm -f fred
if [ -f fred ];then
	:
else
	echo "file fred did not exist"
fi

exit 0
```
#####continue命令
非常类似C语言中的同名语句，这个命令使for、while或until循环跳到下一次循环继续执行，循环变量取循环列表中的下一个值
```bash
#!/bin/sh
rm -rf fred*
echo > fred1
echo > fred2
mkdir fred3
echo > fred4

for file in fred*
do 
	if [ -d "$file" ];then
		echo "skipping directory $file"
		continue
	fi
	echo "file is $file"
done

rm -rf fred*
exit 0
```
输出
```text
file is fred1
file is fred2
skipping directory fred3
file is fred4
```
continue可以带一个可选的参数以表示希望继续执行的循环嵌套层数，也就是说你可以部分地跳出嵌套循环。这个参数很少使用，因为它会导致脚本程序极难理解，例如：
```bash
for x in 1 2 3
do
	echo before $x
	continue 1
	echo after $x
done
```
输出
```text
before 1
before 2
before 3
```
#####.命令
点`.`命令用于在当前shell中执行命令
```bash
. ./shell_script
```
 - 通常，当一个脚本执行一条外部命令或脚本程序时，它会创建一个新的环境(一个子shell)，命令将在这个新环境中执行，在命令执行完毕后，这个环境被丢弃，留下退出码返回给父shell。但外部的source命令和点命令(这两个命令差不多是同义词)在执行脚本程序中列出的命令时，使用的是调用该脚本程序的同一个shell				
 - 因为在默认情况下，shell脚本程序会在一个新创建的环境中执行，所以脚本程序对环境变量所作的任何修改都会丢失。而点命令允许执行的脚本程序改变当前环境。当你要把一个脚本当作“包裹器”来为后续执行的一些其他命令设置环境时，这个命令通常就很有用。例如，如果你正同时参与几个不同的项目，你就可能会遇到需要使用不同的参数来调用命令的情况，比如说调用一个老版本的编译器来维护一个旧程序。			
 - 在shell脚本程序中，点命令的作用有点类似于C或C++语言里的#include指令。尽管它并没有从字面意义上包含脚本，但它的确是在当前上下文中执行命令，所以你可以使用它将变量和函数定义结合进脚本程序。

假设你有两个包含环境设置的文件，它们分别针对两个不同的开发环境，为了设置老的，经典命令的环境，你可以使用文件classic_set,内容如下:
```bash
#!/bin/sh
version=classic
PATH=/usr/local/old_bin:/usr/bin:/bin:
PS1="classic> "
```
对于新命令，使用文件latest_set:
```bash
#!/bin/sh
version=latest
PATH=/usr/local/new_bin:/usr/bin:/bin:
PS1="latest version> "
```
你可以通过将这些脚本程序和点命令结合来设置环境，就像下面这样:
```text
. ./classic_set
classic > echo $verion
classic
classic > . ./latest_set
latest version> echo $version
latest
latest version> 
```
这个脚本使用点命令执行，所以每个脚本程序都是在当前shell中执行，这使得脚本程序可以改变当前shell中的环境变量，即使脚本程序执行结束后，这个改变仍然有效。
#####echo命令
虽然，X/Open建议在现代shell中使用printf命令，但我们还是依照常规使用echo命令来输出结尾带有换行符的字符串。
一个常见的问题是如何去掉换行符，遗憾的是，不同版本的UNIX对这个问题有着不同的解决方法，linux常用的解决方法如下所示：
```bash
echo -n "String to output"
```
或者
```bash
echo -e "string to output\c"
```
 - 第二种方法echo -e确保启用了反斜线转义字符(如\c代表去掉换行符，\t代表制表符，\n代表回车)的解释。在老版本的bash中，对反斜线转义字符的解释通常都是默认启用的，但最新版本的bash通常在默认情况下都不对反斜线转义字符进行解释。你所使用的Linux发行版的详细行为请查看相关手册。
 - 如果你需要一种删除结尾换行符的可移植方法，则可以使用外部命令tr来删除它，但它执行的速度比较慢。如果你需要自己的脚本兼容UNIX系统并且需要删除换行符，最好坚持使用printf命令，如果你的脚本只需要运行在Linux和bash上，那么echo -n是不错的选择，虽然你可能需要在脚本的开头加上#!/bin/bash，以明确表示你需要bash风格的行为。

####eval命令
eval命令允许你对参数进行求值，它是shell的内置命令，通常不会以单独命令的形式存在。我们借用X/Open规范中的一个小例子来演示它的用法:
```bash
#!/bin/sh
foo=10
x=foo
y='$'$x
echo $y #输出 $foo
```
```bash
#!/bin/sh
foo=10
x=foo
eval y='$'$x
echo $y #输出10
```
 - 因此，eval命令有点像一个额外的$,它给出一个变量的值的值，
 - eval命令十分有用，它允许代码被随时生成和运行，虽然它的确增加了脚本调试的复杂度，但它可以让你完成使用其他方法难以或者根本无法完成的事情。

#####exec命令
exec命令有两种不同的用法。它的典型用法是将当前shell替换为一个不同的程序，例如:
```bash
exec wall "Thanks for all the fish"
```
脚本中的这个命令会用wall命令替换当前的shell.脚本程序中exec命令后面的代码都不会执行，因为执行这个脚本的shell已经不存在了。				
exec的第二种用法是修改当前文件描述符：
```bash
exec 3> afile
```
这使得文件描述符3被打开以便从文件afile中读取数据。这种用法非常少见。
#####exit n命令
exit命令使脚本程序以退出码n结束运行。如果你在任何一个交互式shell的命令提示符中使用这个命令，它都会让你退出系统。如果你允许自己的脚本程序在退出时不指定一个退出状态，那么该脚本中最后一条被执行命令的状态将被用作为返回值。在脚本程序中提供一个退出码总是一个良好的习惯。			
在shell脚本编程中，退出码0表示成功，退出码1~125是脚本程序使用的错误代码。其余数字具有保留含义
```text
退出码			说明
126				文件不可执行
127				命令未找到
128及以上		出现一个信号
```
用0表示成功对于许多C/C++程序员来说有些不寻常。在脚本程序中，这种做法的一大优点是允许我们使用多达125个用户自定义的错误代码而不需要提供一个全局性的错误代码变量。			
下面是一个简单的例子，如果当前目录下存在一个名为.profile的文件，它就返回0表示成功：
```bash
#!/bin/sh
if [ -f .profile ];then
	exit 0
fi

exit 1
```
如果你是个精益求精的人，或至少追求更简洁的脚本，那么你可以组合使用前面介绍过的AND和OR列表来重写这个脚本程序，只需要一行代码：
```bash
[ -f .profile ] && exit 0 || exit 1
```
#####export命令
export命令将作为它参数的变量导出到子shell中，并使之在子shell中有效。 在默认情况下，在一个shell中被创建的变量在这个shell调用的下级（子）shell中是不可用的。export命令把自己的参数创建为一个环境变 量，而这个环境变量可以被其他脚本和当前程序调用的程序看见。从更技术的角度来说，被导出的变量构成从该shell衍生的任何子进程的环境变量。我们用下 面两个脚本程序export1和export2来说明它的用法。				
我们先列出脚本程序export2
```bash
#!/bin/sh
echo "$foo"
echo "$bar"
```
然后是脚本程序export1。在这个脚本的结尾，我们调用了export2
```bash
#!/bin/sh
foo="The first meta-syntactic variable"
export bar="The second meta-syntactic variable"

export 2
```
运行这个脚本程序，将得到如下的输出：
```text
./export1

The second meta-syntactic variable
```
 - export2脚本只是回显两个变量的值。export1脚本同时设置两个变量，但只导出变量bar，所以当它其后调用export2时，变量foo的值已丢失，但变量bar的值已被导出到第二个脚本中，脚本输出中第一个空行的出现是因为$foo在export2中没有定义，回显一个null变量将输出一个空行。
 - 一旦一个变量被shell导出，它就可以被shell调用的任何脚本使用，也可以被后续依次调用的任何shell使用。如果脚本export2调用了另一个脚本，bar的值对新脚本来说依然有效。
 - `set -a`或`set -allexport`命令将导出它之后声明的所有变量。

#####expr命令




